<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>V8引擎中的排序 | 前路漫漫</title>
    <meta name="description" content="前路漫漫 当克己 当慎独">
    
    
    <link rel="preload" href="/assets/css/0.styles.6dd12250.css" as="style"><link rel="preload" href="/assets/js/app.0623bd66.js" as="script"><link rel="preload" href="/assets/js/2.5dd5749f.js" as="script"><link rel="preload" href="/assets/js/22.1e32b4b7.js" as="script"><link rel="prefetch" href="/assets/js/10.fc6c68bf.js"><link rel="prefetch" href="/assets/js/11.ba650025.js"><link rel="prefetch" href="/assets/js/12.c6bd3826.js"><link rel="prefetch" href="/assets/js/13.65bc4a49.js"><link rel="prefetch" href="/assets/js/14.91612579.js"><link rel="prefetch" href="/assets/js/15.d9728f90.js"><link rel="prefetch" href="/assets/js/16.0cdff337.js"><link rel="prefetch" href="/assets/js/17.9b49432d.js"><link rel="prefetch" href="/assets/js/18.c6c32b37.js"><link rel="prefetch" href="/assets/js/19.d06222f2.js"><link rel="prefetch" href="/assets/js/20.8888a134.js"><link rel="prefetch" href="/assets/js/21.e7f0e2c3.js"><link rel="prefetch" href="/assets/js/23.2bdf04ee.js"><link rel="prefetch" href="/assets/js/24.2c3bbe4d.js"><link rel="prefetch" href="/assets/js/25.d1292960.js"><link rel="prefetch" href="/assets/js/26.6cabc15b.js"><link rel="prefetch" href="/assets/js/27.0d0f2ae0.js"><link rel="prefetch" href="/assets/js/28.d8f98424.js"><link rel="prefetch" href="/assets/js/3.1a1f1fe3.js"><link rel="prefetch" href="/assets/js/4.7d273734.js"><link rel="prefetch" href="/assets/js/5.e11c7487.js"><link rel="prefetch" href="/assets/js/6.3195bf77.js"><link rel="prefetch" href="/assets/js/7.c30685e8.js"><link rel="prefetch" href="/assets/js/8.8adcad81.js"><link rel="prefetch" href="/assets/js/9.f7bc9cde.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6dd12250.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/images/logo.png" alt="前路漫漫" class="logo"> <span class="site-name can-hide">前路漫漫</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">所有博客</a></div><div class="nav-item"><a href="http://gofrontend.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人网站
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/SmileSmith/Blogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">所有博客</a></div><div class="nav-item"><a href="http://gofrontend.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人网站
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/SmileSmith/Blogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>V8引擎中的排序</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/201901/GettingThingsSortedInV8.html#背景" class="sidebar-link">背景</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#更有趣的是，属性访问器和原型链的相互影响" class="sidebar-link">更有趣的是，属性访问器和原型链的相互影响</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#v8在实际排序之前做了什么" class="sidebar-link">V8在实际排序之前做了什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#历史" class="sidebar-link">历史</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#介绍-v8-torque" class="sidebar-link">介绍 V8 Torque</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#将-array-sort-迁移到-torque" class="sidebar-link">将 Array # sort 迁移到 Torque</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#timsort" class="sidebar-link">TimSort</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#在-torque-中实现-timsort" class="sidebar-link">在 Torque 中实现 Timsort</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#排序状态" class="sidebar-link">排序状态</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#性能妥协" class="sidebar-link">性能妥协</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#微基准测试" class="sidebar-link">微基准测试</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#web-工具基准测试" class="sidebar-link">Web 工具基准测试</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#内存影响" class="sidebar-link">内存影响</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201901/GettingThingsSortedInV8.html#结论" class="sidebar-link">结论</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="v8引擎中的排序"><a href="#v8引擎中的排序" class="header-anchor">#</a> V8引擎中的排序</h1> <p>发布于 2018年9月28日</p> <p>Array.prototype.sort 是V8引擎中最后一批采用JavaScript自托管实现的内置函数之一。在移植它的过程中，我们进行了不同算法和实施策略的实验，最终在V8引擎的7.0（Chrome 70）中发布了排序稳定的版本。</p> <h2 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h2> <p>在JavaScript中排序并不简单。这篇博客介绍了排序算法和JavaScript语言特性结合中的一些问题，并记录了我们将V8转移到稳定算法并使性能更具可预测性的过程。</p> <p>当比较不同的排序算法时，我们将它们的最差性能和平均性能，看作是对内存访问或比较次数的渐近增长（即“大O”符号）的约束。请注意，在动态语言（如JavaScript）中，比较操作通常比内存访问更昂贵。这是因为在排序时比较两个值通常涉及对用户代码的调用。</p> <p><em><strong>译注：客户代码理解为排序中引擎外的代码，比如我们再用Array.prototype.sort一般会传入回调函数 [...].sort((a, b)=&gt; a-b); 没有回调的情况也会有值处理，比如[1,'2']，在比较数字和字符串前，Javascript会做类型转换。</strong></em></p> <p>让我们看一个简单的示例：基于用户提供的比较函数将一些数字按升序排序的。当a比b更小、相等、更大时，比较函数分别返回-1（或任何其他负值）、0、1（或任何其他正值）。不遵循此模式的比较函数则不兼容，并且可能具有任意副作用，例如修改要排序的数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 任意代码, 例如 `array.push(1);`</span>
  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 一个“典型的”sort调用</span>
array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>compare<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>即使在下面这个不传入回调函数的示例中，也可能会发生对用户代码的调用。比较函数，“默认”地，会在两个要比较的值上调用toString，并对返回的两个字符串进行字典比较。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

array<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 任意代码, 例如 `array.push(1);`</span>
    <span class="token keyword">return</span> <span class="token string">'42'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 没有比较函数的sort</span>
array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="更有趣的是，属性访问器和原型链的相互影响"><a href="#更有趣的是，属性访问器和原型链的相互影响" class="header-anchor">#</a> 更有趣的是，属性访问器和原型链的相互影响</h2> <p>在本节内容中，我们抛开规范，开始尝试“定义具体实现”的旅程。规范有一个完整的条件列表，当满足时，允许引擎用它认为合适的方式，对对象/数组进行排序 - 或者根本不对它进行排序。虽然排序的使用者必须遵循一些基本规则，但其他的一切几乎都在空气中（抛诸脑后，不管不顾的意思）。一方面，这使得引擎开发人员可以自由地尝试不同的实现。另一方面，用户期得到一些合理的表现，即使规范中并没有要求。由于“合理的表现”并不总是直接明确定义的，导致事情变得更加复杂。</p> <p>本节说明，在不同的引擎中，Array#sort在一些方面仍然表现出很大的差别。这些大多是一些边缘的场景，如上所述，在这些场景中，并不总是明确“合理的表现”应该是什么。我们强烈建议不要编写这样的代码，引擎不会优化它。</p> <p>第一个示例显示了，在不同JavaScript引擎中一个数组的排序过程，其中包含一些内存访问（即getter和setter）以及“日志打印”。访问器是第一个例子，展示“定义具体实现”对排序结果的影响：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get 0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set 0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>下面是不同Javascript引擎中这段代码的输出。请注意，这里没有“正确”或“错误”的答案 -- 因为规范中并没有明确，而是将其留给不同引擎的实现！</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">get</span> <span class="token number">0</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">set</span> <span class="token number">0</span>
<span class="token keyword">set</span> <span class="token number">1</span>

<span class="token comment">// JavaScriptCore</span>
<span class="token keyword">get</span> <span class="token number">0</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">get</span> <span class="token number">0</span>
<span class="token keyword">get</span> <span class="token number">0</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">set</span> <span class="token number">0</span>
<span class="token keyword">set</span> <span class="token number">1</span>

<span class="token comment">// V8</span>
<span class="token keyword">get</span> <span class="token number">0</span>
<span class="token keyword">get</span> <span class="token number">0</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">get</span> <span class="token number">0</span>

#### SpiderMonkey
<span class="token keyword">get</span> <span class="token number">0</span>
<span class="token keyword">get</span> <span class="token number">1</span>
<span class="token keyword">set</span> <span class="token number">0</span>
<span class="token keyword">set</span> <span class="token number">1</span>
</code></pre></div><p>下一个示例展示了原型链对排序结果的影响。为简洁起见，我们不进行日志打印。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'d1'</span><span class="token punctuation">,</span>
 <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'c1'</span><span class="token punctuation">,</span>
 <span class="token number">3</span><span class="token operator">:</span> <span class="token string">'b1'</span><span class="token punctuation">,</span>
 <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
 __proto__<span class="token operator">:</span> <span class="token punctuation">{</span>
   length<span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>
   <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'e2'</span><span class="token punctuation">,</span>
   <span class="token number">10</span><span class="token operator">:</span> <span class="token string">'a2'</span><span class="token punctuation">,</span>
   <span class="token number">100</span><span class="token operator">:</span> <span class="token string">'b2'</span><span class="token punctuation">,</span>
   <span class="token number">1000</span><span class="token operator">:</span> <span class="token string">'c2'</span><span class="token punctuation">,</span>
   <span class="token number">2000</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
   <span class="token number">8000</span><span class="token operator">:</span> <span class="token string">'d2'</span><span class="token punctuation">,</span>
   <span class="token number">12000</span><span class="token operator">:</span> <span class="token string">'XX'</span><span class="token punctuation">,</span>
   __proto__<span class="token operator">:</span> <span class="token punctuation">{</span>
     <span class="token number">0</span><span class="token operator">:</span> <span class="token string">'e3'</span><span class="token punctuation">,</span>
     <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'d3'</span><span class="token punctuation">,</span>
     <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'c3'</span><span class="token punctuation">,</span>
     <span class="token number">3</span><span class="token operator">:</span> <span class="token string">'b3'</span><span class="token punctuation">,</span>
     <span class="token number">4</span><span class="token operator">:</span> <span class="token string">'f3'</span><span class="token punctuation">,</span>
     <span class="token number">5</span><span class="token operator">:</span> <span class="token string">'a3'</span><span class="token punctuation">,</span>
     <span class="token number">6</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>下面是这个 对象 执行排序后的结果。同样，这里没有所谓的正确答案。此示例仅展示了索引属性与原型链之间的交互有多奇怪：</p> <p><em><strong>译注：类似伪数组</strong></em></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// Chakra</span>
<span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span>

<span class="token comment">// JavaScriptCore</span>
<span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span>

<span class="token comment">// V8</span>
<span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span>

<span class="token comment">// SpiderMonkey</span>
<span class="token punctuation">[</span><span class="token string">'a2'</span><span class="token punctuation">,</span> <span class="token string">'a3'</span><span class="token punctuation">,</span> <span class="token string">'b1'</span><span class="token punctuation">,</span> <span class="token string">'b2'</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">,</span> <span class="token string">'c2'</span><span class="token punctuation">,</span> <span class="token string">'d1'</span><span class="token punctuation">,</span> <span class="token string">'d2'</span><span class="token punctuation">,</span> <span class="token string">'e3'</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span>
</code></pre></div><h2 id="v8在实际排序之前做了什么"><a href="#v8在实际排序之前做了什么" class="header-anchor">#</a> V8在实际排序之前做了什么</h2> <p>V8在实际排序之前有两个预处理步骤。</p> <p>首先，如果要排序的对象在原型链上有孔和元素，会将它们从原型链复制到对象本身。这样在后续所有步骤中，我们都不需要再关注原型链。目前，V8只会对非标准的JSArrays进行这样的处理，而其它引擎对于标准的JSArrays也会进行这样的复制处理。</p> <p><img src="https://raw.githubusercontent.com/SmileSmith/Blogs/master/201901/images/v8_1.png" alt="图1：从原型链中复制"></p> <p>第二个预处理步骤是去孔（hole）。V8引擎会将排序范围中的所有元素都移动到对象的开头。之后移动 undefined。这在某种程度上其实是规范所要求的，因为规范要求引擎始终将undefined排序到最后。这样nbbbb，undefined永远都不会作为的参数去调用用户提供的比较函数。在第二个预处理步骤之后，排序算法只需要考虑 非undefined的，这可以减少实际排序的元素的数量。</p> <p><img src="https://raw.githubusercontent.com/SmileSmith/Blogs/master/201901/images/v8_2.png" alt="图2：移除孔并将undefined移动到最后"></p> <h2 id="历史"><a href="#历史" class="header-anchor">#</a> 历史</h2> <p>Array.prototype.sort 和 TypedArray.prototype.sort 都基于同一种用JavaScript编写的Quicksort实现。排序算法本身非常简单：基础是一个Quicksort（快速排序），对于较短的数组（长度&lt;10）则降级为插入排序（Insertion Sort）。</p> <p>当Quicksort在分治的处理中递归出长度小于10的子数组时，也使用插入排序处理。因为插入排序对于较短的数组更高效。这是因为Quicksort在分区后，需要递归调用两次。每个这样的递归调用都有创建（和丢弃）栈帧的开销。</p> <p>所以选择合适的轴元素（pivot）对Quicksort的性能有着很大的影响。V8采用了两条策略：</p> <ul><li>找到数组中的第一个，最后一个和“第三个”元素，然后选择这三个元素的中间值作为pivot。对于较短数组，“第三个”的的元素就是中间 元素。</li> <li>对于较长的数组，就从中抽出一个小数组进行排序，并将排序后中位数作为上述计算中的“第三个”元素。</li></ul> <p>Quicksort的优点之一是：它是就地排序，不需要太多的内存开销。只有在处理大型数组时，需要为选择的样本数组分配内存，以及log（n）栈空间。它的缺点是：它不是稳定的排序算法，并且在最坏情况下，时间复杂度会降级到O（n^2）。</p> <h2 id="介绍-v8-torque"><a href="#介绍-v8-torque" class="header-anchor">#</a> 介绍 V8 Torque</h2> <p>如果您是V8开发者博客的爱好者，可能听说过 <a href="https://v8.dev/blog/csa" target="_blank" rel="noopener noreferrer">CodeStubAssembler<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，或简称 CSA。CSA是V8的一个组件，它允许我们直接用C ++编写低级别的TurboFan IR（TurboFan 中间层，见译注），后来用TurboFan的后端（编译器后端）将其合理结构的机器码。</p> <p><em><strong>译注：见CSA的链接，比较早了。TurboFan IR是V8自己搞的，相比于传统的基于图的中间层，特别做了些优化，想具体了解的话搜搜大牛的文章吧</strong></em></p> <p>CSA被大量应用于为JavaScript内置函数编写所谓的“快速路径”。内置的“快速路径”版本通常检查某些特别的条件是否成立（例如原型链上没有元素，没有访问器等），然后使用更快，更特殊优化的操作来实现内置函数的功能。这可以使函数执行时间比通用版本快一个数量级。</p> <p>CSA的缺点是它确实可以被认为是汇编语言。流程控制使用明确的 <code>label</code> 和 <code>goto</code>进行建模，这使得在CSA中实现复杂算法时，代码会难以阅读且容易出错。</p> <p>然后是<a href="https://v8.dev/docs/torque" target="_blank" rel="noopener noreferrer">V8 Torque<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。Torque是一种领域专用语言，具有类似TypeScript的语法，目前使用CSA作为其唯一的编译目标。Torque允许开发者使用与CSA几乎相同层次的流程控制操作，同时提供更高级别的构造，例如while和for循环。此外，它是强类型的，并且将来还会包含类似自动越界这样的安全检查，为V8引擎的工程师提供更强大的保障。</p> <p>用V8 Torque重写的第一个重要的内置函数是 <a href="https://v8.dev/blog/v8-release-68" target="_blank" rel="noopener noreferrer">TypedArray＃sort<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://v8.dev/blog/dataview" target="_blank" rel="noopener noreferrer">Dataview<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。这两者的重写都有另外的目的，即向Torque开发人员反馈所需要的语言功能，以及使用哪些模式会可以更高效地编写内置函数。在撰写本文时，多个JSArray的内置函数和对应的自托管的JavaScript后降级实现，已经迁移至Torque（例如，Array＃unshift），其余的则被完全重写（例如，Array＃splice和Array＃reverse）。</p> <h2 id="将-array-sort-迁移到-torque"><a href="#将-array-sort-迁移到-torque" class="header-anchor">#</a> 将 <code>Array # sort</code> 迁移到 Torque</h2> <p>最初的<code>Array＃sort</code> Torque版本或多或少可以说就是JavaScript实现的直接搬运。唯一的区别是，对较长的数组不进行小数组采样，而是随机选择数组中的某个元素作为轴元素选择中的“第三个”元素。</p> <p>这种方式运行得相当不错，但由于它仍然使用Quicksort，因此 Array＃sort仍然是不稳定。请求<a href="https://bugs.chromium.org/p/v8/issues/detail?id=90" target="_blank" rel="noopener noreferrer">稳定版本的<code>Array＃sort</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是V8的bug记录器中最古老的工单之一。接下来尝试用Timsort替代，在这个尝试中我们得到了多种好处。首先，我们喜欢它是一个稳定的算法，并提供一些很好的算法保证（见下一节）。其次，Torque仍然是一个正在开发中的项目，在Torque中用Timsort实现复杂的内置函数，例如“Array＃sort”，可以给Torque语言的本身带来很多可操作性的建议。</p> <h2 id="timsort"><a href="#timsort" class="header-anchor">#</a> TimSort</h2> <p>最早由蒂姆·彼得斯（Tim Peters）于2002年开发的Timsort，可以被认为是自适应的稳定的归并排序（Mergesort）的变种。其实现细节相当复杂，最好去参阅<a href="https://github.com/python/cpython/blob/master/Objects/listsort.txt" target="_blank" rel="noopener noreferrer">作者本人的说明<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>或 <a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener noreferrer">维基百科<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，基础概念应该很容易理解。虽然Mergesort使用递归的方式，但Timsort是以迭代进行。Timsort从左到右迭代一个数组，并寻找所谓的_runs_。一个run可以认为是已经排序的小数组，也包括以逆向排序的，因为这些数组可以简单地翻转（reverse）就成为一个run。在排序过程开始时，算法会根据输入数组的长度，确定一个run的最小长度。如果Timsort无法在数组中找到满足这个最小长度的run，则使用插入排序（Insertion Sort）“人为地生成”一个run。</p> <p>找到的 runs在一个栈中追踪，这个栈会记录起始的索引位置和每个run的长度。栈上的run会逐渐合并在一起，直到只剩下一个排序好的run。在确定合并哪些run时，Timsort会试图保持两方面的平衡。一方面，您希望尽早尝试合并，因为这些run的数据很可能已经在缓存中，另一方面，您希望尽可能晚地合并，以利用数据中可能出现的某些特征。为了实现这个平衡，Timsort遵循保两个原则。假设<code>A</code>，<code>B</code>和<code>C</code>是三个最顶级的runs：</p> <ul><li>|C| &gt; |B| + |A|</li> <li>|B| &gt; |A|</li></ul> <p><em><strong>译注：这里的大于指长度大于</strong></em></p> <p><img src="https://raw.githubusercontent.com/SmileSmith/Blogs/master/201901/images/v8_3.png" alt="图3：A 和 B 合并前后的栈"></p> <p>在上图的例子中，因为| A |&gt; | B |，所以B被合并到了它前后两个runs（A、C）中较小的一个。请注意，Timsort仅合并连续的run，这是维持算法稳定性所必需的，否则大小相等元素会在run中转移。此外，第一个原则确保了run的长度，最慢也会以斐波那契（Fibonacci）数列增长，这样当我们知道数组的最大边界时，runs栈大小的上下界也可以确定了。</p> <p>现在可以看出，对于已经排序好的数组，会以O（n）的时间内完成排序，因为这样的数组将只产生单个run，不需要合并操作。最坏的情况是O（n log n）。这样的算法性能参数，以及Timsort天生的稳定性是我们最终选择Timsort而非Quicksort的几个原因。</p> <h2 id="在-torque-中实现-timsort"><a href="#在-torque-中实现-timsort" class="header-anchor">#</a> 在 Torque 中实现 Timsort</h2> <p>内置函数通常具有不同的代码版本，在运行时（runtime）会根据各种变量选择合适的代码版本。而通用的版本则可以处理任何类型的对象，无论它是一个<code>JSProxy</code>，有拦截器，还是在查找/设置属性时有原型链查询。</p> <p>在大多数情况下，通用的路径版本相当慢，因为它需要考虑所有的可能性。但是如果我们事先知道要排序的对象是一个只包含Smis的简单<code>JSArray</code>，所有这些昂贵的<code>[[Get]]</code>和<code>[[Set]]</code>操作都可以被简单地替换为<code>FixedArray</code>的Loads和Stores。主要的区别在于<a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener noreferrer">ElementsKind<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p><em><strong>译注：ElemenKind简单来讲，就是一个数组的元素类型，比如[1, 2]是ElementKind是Int，[1, 2.1]则是Double</strong></em></p> <p>现在问题变成了如何实现快速路径。除了基于ElementsKind的不同更改访问元素的方式之外，核心算法对所有场景保持相同。一种实现方案是：对每个操作都分配合适的“访问器（accessor）”。想象一下每个“加载”/“存储”（“load”/”store”）都有一个开关，我们通过开关来选择不同快速路径的分支。</p> <p>另一个实现方案（这是最开始尝试的方式）是为对每个快速路径都复制整个内置函数并内联合适的加载/存储方法（load/store）。但这种方式对于Timsort来说是不可行的，因为它是一个很大的内置函数，复制每个快速路径总共需要106 KB的空间，这对于单个内置函数来说太过分了。</p> <p>最终的方案略有不同。每个快速路径的每个加载/存储方法（load/store）都被放入其自己的“迷你内置函数”中。请参阅代码示例，其中展示了针对“FixedDoubleArray”的“加载”（load）操作。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Load<span class="token operator">&lt;</span>FastDoubleElements<span class="token operator">&gt;</span><span class="token punctuation">(</span>
    context<span class="token operator">:</span> Context<span class="token punctuation">,</span> sortState<span class="token operator">:</span> FixedArray<span class="token punctuation">,</span> elements<span class="token operator">:</span> HeapObject<span class="token punctuation">,</span>
    index<span class="token operator">:</span> Smi<span class="token punctuation">)</span><span class="token operator">:</span> Object <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> elems<span class="token operator">:</span> FixedDoubleArray <span class="token operator">=</span> UnsafeCast<span class="token operator">&lt;</span>FixedDoubleArray<span class="token operator">&gt;</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> value<span class="token operator">:</span> float64 <span class="token operator">=</span>
        <span class="token function">LoadDoubleWithHoleCheck</span><span class="token punctuation">(</span>elems<span class="token punctuation">,</span> index<span class="token punctuation">)</span> otherwise Bailout<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">AllocateHeapNumberWithValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  label Bailout <span class="token punctuation">{</span>
    <span class="token comment">// 预处理步骤中，通过把所有元素移到数组最前的方式 已经移除了所有的孔</span>
    <span class="token comment">// 这时如果找到了孔，说明 cmp 函数或 ToString 改变了数组</span>
    <span class="token keyword">return</span> <span class="token function">Failure</span><span class="token punctuation">(</span>sortState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>相比之下，最通用的“加载”操作（load）只是对GetProperty的调用。相比于上述版本生成了高效且快速的机器代码来加载和转换Number，GetProperty只是对另一个内置函数的调用，这之中可能涉及对原型链的查找或访问器函数的调用。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>builtin Load<span class="token operator">&lt;</span>ElementsAccessor <span class="token operator">:</span> type<span class="token operator">&gt;</span><span class="token punctuation">(</span>
    context<span class="token operator">:</span> Context<span class="token punctuation">,</span> sortState<span class="token operator">:</span> FixedArray<span class="token punctuation">,</span> elements<span class="token operator">:</span> HeapObject<span class="token punctuation">,</span>
    index<span class="token operator">:</span> Smi<span class="token punctuation">)</span><span class="token operator">:</span> Object <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">GetProperty</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样一来，快速路径就变成一组函数指针。这意味着我们只需要核心算法的一个副本，同时预先设置所有相关函数的指针。虽然这大大减少了所需的代码空间（低至20k），但却以每个访问点的使用不同的间接分支做为减少的代价。这种情况在最近引入<a href="https://v8.dev/blog/embedded-builtins" target="_blank" rel="noopener noreferrer">嵌入式内置函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的变更后加剧了。</p> <h2 id="排序状态"><a href="#排序状态" class="header-anchor">#</a> 排序状态</h2> <p><img src="https://raw.githubusercontent.com/SmileSmith/Blogs/master/201901/images/v8_4.png" alt="图4：排序状态列表"></p> <p>上图显示了“排序状态”。它是一个FixedArray，展示了排序时涉及到的所有内容。每次调用Array＃sort时，都会分配这种排序状态。期中04到07是上面讨论的构成快速路径的一组函数指针。</p> <p>每次在用户的JavaScript代码返回（return）时都会调用内置函数“check”，以检查我们是否可以继续使用当前的快速路径。它使用“initial receiver map”和“initial receiver length”来做检查。如果用户代码修改了当前对象，我们只需放弃排序运行，将所有指针重置为最通用的版本并重新启动排序的过程。08中的“救助状态”作为重置的信号。
“compare”可以指向两个不同的内置函数。一个调用用户提供的比较函数，另一个上面说的默认比较（对两个参数执行toString，然后进行字典比较）。</p> <p>其余字段（14：Fast path ID除外）都是Timsort所特有的。运行时的run栈（如上所述）初始化长度为85，这足以对长度为264的数组进行排序。而用于合并运行临时数组的长度，会根据运行时的需要所增大，但绝不超过n / 2，其中n是输入数组的长度。</p> <h2 id="性能妥协"><a href="#性能妥协" class="header-anchor">#</a> 性能妥协</h2> <p>将 Array # sort 的自托管JavaScript实现转移到Torque需要进行一些性能权衡。由于<code>Array＃sort</code>是用Torque编写的，它现在是一段静态编译的代码，这意味着我们仍然可以为默认特定的 ElementsKind`s构建快速路径，但它永远不会比 TurboFan 高度优化的代码更快，因为TurboFan可以利用类型反馈进行优化。另一方面，如果代码没有足够热以保证JIT编译或者调用点是复态（megamorphic）的，我们就会被卡在解释器或慢速/通用的版本。自托管JavaScript实现版本中的解析，编译和可能的优化过程中所产生的开销，在Torque实现版本中也都不需要了。</p> <p>虽然Torque的实现方案无法让排序达到相同峰值性能，但它确实避免了性能断崖。结果是排序的性能比以前更容易预测。请注意，Torque还在不停的迭代中，除了编译到CSA之外，它可能会在未来支持编译到TurboFan，允许JIT去编译用Torque编写的代码。</p> <h2 id="微基准测试"><a href="#微基准测试" class="header-anchor">#</a> 微基准测试</h2> <p>在我们着手开发Array＃sort之前，我们添加了一系列不同的微基准测试，以便更好地了解重写对性能的影响。第一个图显示了使用用户提供的比较函数对各种ElementsKinds进行排序的“正常”用例。</p> <p>请注意，在这些情况下，JIT编译器会做很多工作，因为排序过程几乎就是我们（引擎）所处理的。虽然这样允许我们在编译器内联JavaScript版本中的比较函数，但在Torque中也会有内置函数到JavaScript的额外调用开销。不过，我们新的Timsort几乎在所有情况下都表现得更好。</p> <p><img src="https://raw.githubusercontent.com/SmileSmith/Blogs/master/201901/images/v8_5.png" alt="图5：随机数/用户提供比较函数，微基础测试"></p> <p>下一个图表显示了：在处理已完全排序的数组，或者具有已单向排序的子序列的数组时，Timsort对性能的影响。下图中采用Quicksort作为基线，展示了Timsort的加速比（在“DownDown”的情况下高达17倍，这个场景中数组由两个反向排序的子序列组成）。可以看出，除了在随机数据的情况下，Timsort在其它所有情况下都表现得更好，即使我们排序的对象是<code>PACKED_SMI_ELEMENTS</code>（Quicksort在上图的微基准测试中对这种对象排序时，性能胜过了Timsort）。</p> <p><img src="https://raw.githubusercontent.com/SmileSmith/Blogs/master/201901/images/v8_6.png" alt="图6：预排序/无孔小整数数组/用户提供比较函数，微基础测试"></p> <h2 id="web-工具基准测试"><a href="#web-工具基准测试" class="header-anchor">#</a> Web 工具基准测试</h2> <p><a href="https://github.com/v8/web-tooling-benchmark" target="_blank" rel="noopener noreferrer">Web Tooling Benchmark<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是在Web开发人员常用工具的JS环境载体（如Babel和TypeScript）中进行的测试。下图采用JavaScript Quicksort作为基线，展示了Timsort的速度提升。除了 chai 我们在几乎所有测试中获得了相同的性能。</p> <p>chai的基准测试中将三分之一的时间用于一个比较函数中（字符串长度计算）。基准测试用的是chai自身的测试套件。由于数据的原因，Timsort在这种情况下需要更多的比较，这对整体的运行有着很大的影响，因为大部分时间都花在了特定的比较函数中。</p> <p><img src="https://raw.githubusercontent.com/SmileSmith/Blogs/master/201901/images/v8_7.png" alt="图7：Web工具的基准测试"></p> <h2 id="内存影响"><a href="#内存影响" class="header-anchor">#</a> 内存影响</h2> <p>在浏览大约50个站点（分别在移动设备和桌面设备上）分析V8堆的快照时，没有显示出任何内存消耗的增加或减少。一方面这很让人意外：从Quicksort到Timsort的转换引入了对合并run操作所需要的临时数组的空间，这应该会比Quicksort用于采样的临时数组大得多。另一方面，其实这些临时数组的存续时间非常短暂（仅在<code>sort</code>调用的持续时间内）并且可以在V8的新空间中非常快速地创建和删除。</p> <h2 id="结论"><a href="#结论" class="header-anchor">#</a> 结论</h2> <p>总的来说，对于在Torque中实现的Timsort的算法属性和可预测的性能，让我们感觉很好。Timsort从V8 v7.0和Chrome 70开始生效。快乐排序吧！</p> <p>作者： Simon Zünd (@nimODota), consistent comparator.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/SmileSmith/Blogs/edit/master/docs/201901/GettingThingsSortedInV8.md" target="_blank" rel="noopener noreferrer">帮助改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">12/29/2019, 11:32:53 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.0623bd66.js" defer></script><script src="/assets/js/2.5dd5749f.js" defer></script><script src="/assets/js/22.1e32b4b7.js" defer></script>
  </body>
</html>
