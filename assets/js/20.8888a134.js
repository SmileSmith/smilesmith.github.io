(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{271:function(e,v,t){"use strict";t.r(v);var s=t(0),_=Object(s.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_2018-11-23"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2018-11-23"}},[e._v("#")]),e._v(" 2018.11.23")]),e._v(" "),t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[e._v("#")]),e._v(" 背景")]),e._v(" "),t("p",[e._v("昨天做CodeReview遇到如下场景：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("页面中有组件A和组件B，同时请求接口X获取配置数据返回Promise（注1）")])]),e._v(" "),t("li",[t("p",[e._v("抓包发现会请求两次，浪费性能，有没有办法从请求层面处理？")])])]),e._v(" "),t("p",[e._v("小伙伴M的处理方法是")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("在请求之前打个标记为已请求hasRequest，发起第 1 个请求")])]),e._v(" "),t("li",[t("p",[e._v("第 2 个请求进来发现已请求，EventBus注册全局事件，就退出")])]),e._v(" "),t("li",[t("p",[e._v("等待第 1 个请求完毕后，resolve返回数据，触发全局事件")])])]),e._v(" "),t("h2",{attrs:{id:"分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[e._v("#")]),e._v(" 分析")]),e._v(" "),t("p",[e._v("上述的做法好处是：")]),e._v(" "),t("ul",[t("li",[e._v("简单直接")])]),e._v(" "),t("p",[e._v("不好的地方：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("EventBus的引入增加代码阅读成本")])]),e._v(" "),t("li",[t("p",[e._v("第 1 个请求成功后resolve后，执行全局事件触发，语义上不够清晰")])]),e._v(" "),t("li",[t("p",[e._v("对于reject没有处理，如果reject处理需要另外注册事件或加字段或加额外判断")])])]),e._v(" "),t("h2",{attrs:{id:"可能的优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可能的优化"}},[e._v("#")]),e._v(" 可能的优化")]),e._v(" "),t("p",[e._v("利用resolve本身是个函数的性质，参考以前多个callback存放数组的处理")]),e._v(" "),t("p",[e._v("可以把多次相同条件的promise的resolve放到一个resolveList数组中，Promise结束后按push的顺序调用resolve")])])}),[],!1,null,null,null);v.default=_.exports}}]);