(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{285:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"让-instagram-com-变得更快-第三章-—-缓存优先"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#让-instagram-com-变得更快-第三章-—-缓存优先"}},[t._v("#")]),t._v(" 让 Instagram.com 变得更快: 第三章 — 缓存优先")]),t._v(" "),n("p",[t._v("最近这几年，instagram.com 变了很多 - 我们在 INS 中加入了 Stories、滤镜、创作工具、系统通知和消息推送等新特性和功能增强。然而，伴随着产品的不断迭代成长，一个不幸的事情发生了：我们的 web 端性能开始下降了。为处理性能下降，在最近的一年中，我们有意识地开展一些工作来提升性能。截止目前，我们的不懈努力已经让 Feed 页面加载时间减少了将近 50%。这个系列的博客文章将会讲述我们为实现这些提升所做的一些工作。在"),n("router-link",{attrs:{to:"/201911/MakingInstagramFaster/[对照版]让Instagram.com变得更快（1）.html"}},[t._v("第一章")]),t._v("中我们主要讨论异步接口和异步资源的预加载，在"),n("router-link",{attrs:{to:"/201911/MakingInstagramFaster/[对照版]让Instagram.com变得更快（2）.html"}},[t._v("第二章")]),t._v("中我们主要讨论通过服务端主动推送数据来提升性能。")],1),t._v(" "),n("h2",{attrs:{id:"缓存优先"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#缓存优先"}},[t._v("#")]),t._v(" 缓存优先")]),t._v(" "),n("p",[t._v("经过前面文章中所说的优化，向客户端推送数据的时间已经被尽可能地提前了。怎么才能让页面更快地获取到数据呢？ 唯一的思路就是不经由网络的请求和推送数据。我们可以采用缓存优先的渲染机制来实现，当然「缓存」也意味着在一定时间内用户会看到之前的页面数据。在这种实现中，一旦页面加载完成，我们会立即给用户展示之前 Feed 和 Story 的副本缓存，并且在新数据可用时覆盖旧的缓存。")]),t._v(" "),n("p",[n("code",[t._v("instagram.com 是使用Redux来管理前端状态，因此我们的实现方式是，在更高层次上将一个Redux Store的子集存储到indexedDB的表中，然后在页面初始化渲染时将indexedDB缓存的数据状态 rehydrate 回store中")]),t._v("。然而，由于 indexedDB 操作、请求服务端数据、用户交互都是异步的，无法判断它们的先后顺序。因此，当用户操作影响到缓存数据时，会遇到一个问题: 我们希望能确保这些对缓存数据的改动，也同样应用在服务端返回的数据。")]),t._v(" "),n("blockquote",[n("p",[t._v("译注: rehydrate 的直译是「注水」，感觉不是很准确，这里不做翻译。更多可以参考: "),n("a",{attrs:{href:"https://www.zhihu.com/question/66068748",target:"_blank",rel:"noopener noreferrer"}},[t._v('react 中出现的"hydrate"这个单词到底是什么意思?'),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("举个例子，如果就按原来的方式直接处理缓存的状态数据，我们会遇到这样的问题：首先，我们同时从缓存和网络加载数据，由于缓存优先的策略，因此缓存数据先渲染给用户。然后，用户对某个 feed 操作了「喜欢」。这之后一旦这个 feed 最新的网络请求返回时，它就会覆盖该 feed 的状态，被覆盖后该 feed 就不包含用户刚刚对 feed 操作的「喜欢」（请参见下图）。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(75),alt:"用户和缓存数据交互时导致的操作被覆盖场景（Redux actions是绿色，State是灰色）"}})]),t._v(" "),n("p",[t._v("为解决这个问题，我们需要一个新的方法，它在处理缓存状态的同时，还要缓存这些对状态的处理操作，然后在服务端返回的数据中重新执行一遍这些操作。如果你有 Git 或其它版本控制工具的经验，这看上去是不是很熟悉？如果把缓存的 feed 当作一个特性分支，把服务端的放回的 feed 当作 master 分支，那么我们要做的其实就是在 master 分支上执行 rebase 操作，把特性分支上的 commit（喜欢、评论等操作）应用到 master 分支中。")]),t._v(" "),n("p",[t._v("这样就有如下的设计:")]),t._v(" "),n("ul",[n("li",[t._v("当页面加载，我们发送请求获取新数据（或等待服务端主动 push 新数据，参考第二章）")]),t._v(" "),n("li",[t._v("创建 1 个暂存的 Redux State 子集")]),t._v(" "),n("li",[t._v("当请求/推送未完成时，把所有已经 dispatch 的 action 存储起来")]),t._v(" "),n("li",[t._v("当请求/推送求完成，新的数据把暂存的State中的数据覆盖，此时把这些存储的 action 和其它等在在暂存的State中待执行的 action 都应用到最新的数据中")]),t._v(" "),n("li",[t._v("当暂存的 State 提交的时候，我们直接把当前的 State 替换成暂存的 State")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(76),alt:"用暂存的快照修复状态覆盖的问题（Redux actions是绿色，State是灰色）"}})]),t._v(" "),n("p",[t._v("通过维持一个暂存状态的 State，所有已经存在的 reducer 行为都可以重复使用，并将暂存 State 和最新 State 分开。另外，我们是使用 Redux 来实现暂存的，因此可以直接使用 dispatch action，非常方便。")]),t._v(" "),n("div",{staticClass:"language-typescript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-typescript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("stagingAction")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" promise"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Promise")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Action"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" AsyncAction"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("State"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Action"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("stagingCommit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" AsyncAction"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("State"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Action"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("暂存 API 主要包含两个方法: "),n("code",[t._v("stagingAction")]),t._v(" & "),n("code",[t._v("stagingCommit")]),t._v(" （当然还有一些还原 State 的方法和处理边界情况的代码，这里就不展开了）")]),t._v(" "),n("p",[n("code",[t._v("stagingAction")]),t._v(" 函数接收 1 个 Promise，这个 Promise 会 resolve 1 个要 dispatch 到暂存 State 的 action。它会初始化时暂存 State，然后保存所有已经 dispatch 的 actions。在 Git 概念里，我们可以把这个操作当作创建 1 个本地分支，因为在新数据到达前，发生的任何操作都将按顺序应用到暂存的State中。")]),t._v(" "),n("p",[n("code",[t._v("stagingCommit")]),t._v(" 函数的作用是暂存的 State 提交到当前 State 中。如果暂存的 State 中还有其它的异步 actions 未执行完，它会一直等待。这非常像 Git 中 rebase 操作: 将所有的本地改动（从缓存的特性分支中来的改动）应用到 master 的 head 前面（服务端返回的新数据），让本地的 master 分支同时应用远程改动和本地改动，从而更新到最新。")]),t._v(" "),n("p",[t._v("为了更方便地使用暂存State，我们在根级的 reducer 上封装了一个 reducer 增强器，它处理所有要暂存的 action，并将所有已暂存的 actions 应用到新的 State 中。这样我们只需要 dispatch 相关 actions 就行，其它的事情这个增强器都处理好了。举个例子，如果我们要请求 1 个新的 feed，并应用到已暂存的 State 中，我们就执行类似下面的逻辑:")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fetchAndStageFeed")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("stagingAction")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'feed'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" data "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fetchFeedTimeline")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                type"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FEED_LOADED")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("data"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 请求最新的 feed 并开始暂存")]),t._v("\nstore"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fetchAndStageFeed")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在此期间，任何已经 dispatched 的actions都会被应用到暂存的State中的 feed")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 直到 stagingCommit 提交暂存的State")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将暂存的State提交到当前的State中")]),t._v("\nstore"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("stagingCommit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'feed'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("我们对 Feed 和 Story 同时使用缓存优先渲染功能，使得页面渲染完成时间缩短了 2.5％和 11％，并且让页面更贴近原生 iOS 和 android的浏览体验。")]),t._v(" "),n("h2",{attrs:{id:"请继续关注第四章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#请继续关注第四章"}},[t._v("#")]),t._v(" 请继续关注第四章")]),t._v(" "),n("p",[t._v("在第4章中，我们将介绍如何减少代码大小，通过代码大小和执行优化来进一步提升性能。 如果您想了解更多有关这项工作的信息，或者有兴趣加入我们的团队，请访问我们的"),n("a",{attrs:{href:"https://www.facebook.com/careers/jobs/?q=instagram",target:"_blank",rel:"noopener noreferrer"}},[t._v("公司岗位页面"),n("OutboundLink")],1),t._v("，也可以关注我们"),n("a",{attrs:{href:"https://www.facebook.com/instagramengineering/",target:"_blank",rel:"noopener noreferrer"}},[t._v("on Facebook"),n("OutboundLink")],1),t._v("或者"),n("a",{attrs:{href:"https://twitter.com/instagrameng",target:"_blank",rel:"noopener noreferrer"}},[t._v("on Twitter"),n("OutboundLink")],1),t._v("。")]),t._v(" "),n("h2",{attrs:{id:"译注"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#译注"}},[t._v("#")]),t._v(" 译注")]),t._v(" "),n("p",[t._v("这边文章核心思路比较简单，比较有意思的地方是用Git版本控制的概念来处冲突问题。其实软件工程中的需要思想都可以互相借鉴，比如前端MVC最早可能参考了Spring，微前端服务参考了后端的微服务")]),t._v(" "),n("p",[t._v("文章中有很多Redux和Git方面的专业词汇，可以参考:")]),t._v(" "),n("ol",[n("li",[n("a",{attrs:{href:"https://www.redux.org.cn/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux中文文档"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://www.codercto.com/a/45325.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git Rebase简介"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=e.exports},75:function(t,a,s){t.exports=s.p+"assets/img/3_1.6b1a5451.png"},76:function(t,a,s){t.exports=s.p+"assets/img/3_2.90ea995d.png"}}]);