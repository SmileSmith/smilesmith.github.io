<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Making Instagram.com faster: Part 2 | 前路漫漫</title>
    <meta name="description" content="前路漫漫 当克己 当慎独">
    
    
    <link rel="preload" href="/assets/css/0.styles.6dd12250.css" as="style"><link rel="preload" href="/assets/js/app.0623bd66.js" as="script"><link rel="preload" href="/assets/js/2.5dd5749f.js" as="script"><link rel="preload" href="/assets/js/8.8adcad81.js" as="script"><link rel="prefetch" href="/assets/js/10.fc6c68bf.js"><link rel="prefetch" href="/assets/js/11.ba650025.js"><link rel="prefetch" href="/assets/js/12.c6bd3826.js"><link rel="prefetch" href="/assets/js/13.65bc4a49.js"><link rel="prefetch" href="/assets/js/14.91612579.js"><link rel="prefetch" href="/assets/js/15.d9728f90.js"><link rel="prefetch" href="/assets/js/16.0cdff337.js"><link rel="prefetch" href="/assets/js/17.9b49432d.js"><link rel="prefetch" href="/assets/js/18.c6c32b37.js"><link rel="prefetch" href="/assets/js/19.d06222f2.js"><link rel="prefetch" href="/assets/js/20.8888a134.js"><link rel="prefetch" href="/assets/js/21.e7f0e2c3.js"><link rel="prefetch" href="/assets/js/22.1e32b4b7.js"><link rel="prefetch" href="/assets/js/23.2bdf04ee.js"><link rel="prefetch" href="/assets/js/24.2c3bbe4d.js"><link rel="prefetch" href="/assets/js/25.d1292960.js"><link rel="prefetch" href="/assets/js/26.6cabc15b.js"><link rel="prefetch" href="/assets/js/27.0d0f2ae0.js"><link rel="prefetch" href="/assets/js/28.d8f98424.js"><link rel="prefetch" href="/assets/js/3.1a1f1fe3.js"><link rel="prefetch" href="/assets/js/4.7d273734.js"><link rel="prefetch" href="/assets/js/5.e11c7487.js"><link rel="prefetch" href="/assets/js/6.3195bf77.js"><link rel="prefetch" href="/assets/js/7.c30685e8.js"><link rel="prefetch" href="/assets/js/9.f7bc9cde.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6dd12250.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/images/logo.png" alt="前路漫漫" class="logo"> <span class="site-name can-hide">前路漫漫</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">所有博客</a></div><div class="nav-item"><a href="http://gofrontend.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人网站
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/SmileSmith/Blogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">所有博客</a></div><div class="nav-item"><a href="http://gofrontend.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  个人网站
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/SmileSmith/Blogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Making Instagram.com faster: Part 2</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/201911/MakingInstagramFaster/Making%20Instagram.com%20faster%20Part%202.html#pushing-data-using-early-flushing-and-progressive-html" class="sidebar-link">Pushing data using early flushing and progressive HTML</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/201911/MakingInstagramFaster/Making%20Instagram.com%20faster%20Part%202.html#stay-tuned-for-part-3" class="sidebar-link">Stay tuned for part 3</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="making-instagram-com-faster-part-2"><a href="#making-instagram-com-faster-part-2" class="header-anchor">#</a> Making Instagram.com faster: Part 2</h1> <p>In recent years, instagram.com has seen a lot of changes — we’ve launched stories, filters, creation tools, notifications, and direct messaging as well as myriad other features and enhancements. However, as the product grew, one unfortunate side effect was that our web performance began to suffer. Over the last year, we made a conscious effort to improve this. Our ongoing efforts have thus far resulted in almost 50% cumulative improvement to our feed page load time. This series of blog posts will outline some of the work we’ve done that led to these improvements.</p> <h2 id="pushing-data-using-early-flushing-and-progressive-html"><a href="#pushing-data-using-early-flushing-and-progressive-html" class="header-anchor">#</a> Pushing data using early flushing and progressive HTML</h2> <p>In <a href="https://instagram-engineering.com/making-instagram-com-faster-part-1-62cc0c327538" target="_blank" rel="noopener noreferrer">part 1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, we showed how using link preloads allows us to start dynamic queries earlier in the page load i.e. before the script that will initiate the request has even loaded. With that said, issuing these requests as a preload still means that the query will not begin until the HTML page has begun rendering on the client, which means the query cannot start until 2 network roundtrips have completed (plus however long it takes to generate the html response on the server). As we can see below for a preloaded GraphQL query, even though it’s one of the first things we preload in the HTML head, it can still be a significant amount of time before the query actually begins.</p> <p><img src="/assets/img/2_1.007f51a2.png" alt="preloaded GraphQL query"></p> <p>The theoretical ideal is that we would want a preloaded query to begin execution as soon as the request for the page hits the server. But how can you get the browser to request something before it has even received any HTML back from the server? The answer is to push the resource from the server to the browser, and while it might look like HTTP/2 push is the solution here, there is actually a very old (and often overlooked) technique for doing this that has universal browser support and doesn’t have any of the infrastructural complexities of implementing HTTP/2 push. Facebook has been using this successfully since 2010 (see <a href="https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919/" target="_blank" rel="noopener noreferrer">BigPipe<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>), as have other sites in various forms such as Ebay — but this technique seems to be largely ignored or unused by developers of JavaScript SPAs. It goes by a few names — early flush, head flushing, progressive HTML — and it works by combining two things:</p> <ul><li>HTTP chunked transfer encoding</li> <li>Progressive HTML rendering in the browser</li></ul> <p><a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding" target="_blank" rel="noopener noreferrer">Chunked transfer encoding<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> was added as part of HTTP/1.1, and essentially it allows an HTTP network response to be broken up into multiple ‘chunks’ which can be streamed to the browser. The browser then stitches these chunks together as they arrive into a final completed response. While this does involve a fairly significant change to how pages are rendered on the server side, most languages and frameworks have support for rendering chunked responses (in the case of Instagram we use Django on our web frontends, so we use the <a href="https://docs.djangoproject.com/en/2.2/ref/request-response/#streaminghttpresponse-objects" target="_blank" rel="noopener noreferrer">StreamingHttpResponse<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> object). The reason this is useful is that it allows us to stream the contents of an HTML page to the browser as each part of the page completes — rather than having to wait for the whole response. This means we can flush the HTML head to the browser almost immediately (hence the term ‘early flush’) as it doesn’t involve much server-side processing. This allows the browser to start downloading scripts and stylesheets while the server is busy generating the dynamic data in the rest of the page. You can see the effect of this below.</p> <p><img src="/assets/img/2_2.c1c3a2d5.png" alt="Without early flush: No resources load until the HTML is fully downloaded"></p> <p><img src="/assets/img/2_3.77c86f97.png" alt="With early flush: Resources start loading as soon as the HTML tags are flushed to the browser"></p> <p>Additionally, we can use chunked encoding to send data to the client as it completes. In the case of server-side rendered applications this could be in the form of HTML, but we can push JSON data to the browser in the case of single page apps like instagram.com. To see how this works, let’s look at the naive case of a single page app starting up. First the initial HTML containing the JavaScript required to render the page is flushed to the browser. Once that script parses and executes, it will then execute an XHR query which fetches the initial data needed to bootstrap the page.</p> <p><img src="/assets/img/2_4.2e685a5d.png" alt="single page app starting up"></p> <p>This process involves multiple roundtrips between the server and client and introduces periods where both the server and client are sitting idle. Rather than have the server wait for the client to request the API response, a more efficient approach would be for the server to start working on generating the API response immediately after the HTML has been generated and to push it to the client. This would mean that by the time the client has started up the data would likely be ready without having to wait for another round trip. The first step in making this change was to create a JSON cache to store the server responses. We implemented this by using a small inline script block in the page HTML that acts as a cache &amp; lists the queries that will be added to this cache by the server (this is shown in a simplified form below).</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token comment">// the server will write out the paths of any API calls it plans to </span>
  <span class="token comment">// run server-side so the client knows to wait for the server, rather</span>
  <span class="token comment">// than doing its own XHR request for the data</span>
  window<span class="token punctuation">.</span>__data <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">'/my/api/path'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        waiting<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  window<span class="token punctuation">.</span><span class="token function-variable function">__dataLoaded</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> cacheEntry <span class="token operator">=</span> window<span class="token punctuation">.</span>__data<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cacheEntry<span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> cacheEntry<span class="token punctuation">.</span>waiting<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cacheEntry<span class="token punctuation">.</span>waiting<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>cacheEntry<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      cacheEntry<span class="token punctuation">.</span>waiting <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>After flushing the HTML to the browser the server can execute the API query itself and when it completes, flush the JSON data to the page as a script tag containing the data. When this HTML response chunk is received and parsed by the browser, it will result in the data being inserted into the JSON cache. A key thing to note with this approach is that the browser will render progressively as it receives response chunks (i.e. they will execute complete script blocks as they are streamed in). So you could potentially generate lots of data in parallel on the server and flush each response in its own script block as it becomes ready for immediate execution on the client. This is the basic idea behind Facebooks BigPipe system where multiple independent Pagelets are loaded in parallel on the server and pushed to the client in the order they complete.</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  window<span class="token punctuation">.</span><span class="token function">__dataLoaded</span><span class="token punctuation">(</span><span class="token string">'/my/api/path'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// API json response, wrapped in the function call to </span>
    <span class="token comment">// add it to the JSON cache...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>When the client script is ready to request its data, instead of issuing an XHR request, it first checks the JSON cache. If a response is present (or pending) it either responds immediately, or waits for the pending response.</p> <div class="language-html extra-class"><pre class="language-html"><code>function queryAPI(path) {
  const cacheEntry = window.__data[path];
  if (!cacheEntry) {
    // issue a normal XHR API request
    return fetch(path);
  } else if (cacheEntry.data) {
    // the server has pushed us the data already
    return Promise.resolve(cacheEntry.data);
  } else {
    // the server is still pushing the data
    // so we'll put ourselves in the queue to 
    // be notified when its ready
    const waiting = {};
    cacheEntry.waiting.push(waiting);
    return new Promise((resolve) =&gt; {
      waiting.resolve = resolve;
    });
  }
}
</code></pre></div><p>This has the effect of changing the page load behavior to this:</p> <p><img src="/assets/img/2_5.167f496c.png" alt="page load behavior"></p> <p>Compared to the naive loading approach, the server and client can now do more work in parallel — reducing idle periods where the server and client are waiting on each other. The impact of this was significant: desktop users experienced a 14% improvement in page display completion time, while mobile users (with higher network latencies) experienced a more pronounced 23% improvement.</p> <h2 id="stay-tuned-for-part-3"><a href="#stay-tuned-for-part-3" class="header-anchor">#</a> Stay tuned for part 3</h2> <p>In part 3 we’ll cover how we further improved performance by taking a cache first approach to rendering data. If you want to learn more about this work or are interested joining one of our engineering teams, please visit our careers page, follow us on Facebook or on Twitter.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/SmileSmith/Blogs/edit/master/docs/201911/MakingInstagramFaster/Making Instagram.com faster Part 2.md" target="_blank" rel="noopener noreferrer">帮助改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">12/29/2019, 11:32:53 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.0623bd66.js" defer></script><script src="/assets/js/2.5dd5749f.js" defer></script><script src="/assets/js/8.8adcad81.js" defer></script>
  </body>
</html>
